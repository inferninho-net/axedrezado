<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Axedrezado no Camiño de Santiago</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-locatecontrol/0.85.1/L.Control.Locate.min.css">


  <style>
html, body { height: 100%; margin: 0; }
/* Em páginas WP, evita 100vh (pode engolir o resto do layout). Ajusta se quiseres. */
#map { height: 70vh; min-height: 360px; width: 100%; }
@supports (height: 70dvh) { #map { height: 70dvh; } }

/* A carregar */
.loading {
  background: rgba(255,255,255,.92);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  padding: 8px 10px;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.20);
  font: 13px/1 system-ui, sans-serif;
  color: #1f2937;
}


/* Caixa do seletor */
.leaflet-control-layers {
  border: 0 !important;
  border-radius: 14px !important;
  box-shadow: 0 10px 30px rgba(0,0,0,.25) !important;
  background: rgba(255,255,255,.92) !important;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  overflow: hidden;
  font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}

/* Botão (ícone) quando está colapsado */
.leaflet-control-layers-toggle {
  width: 42px !important;
  height: 42px !important;
  border-radius: 12px !important;
}

/* Conteúdo interno */
.leaflet-control-layers-expanded {
  max-width: 260px;
}

}

/* Separador */
.leaflet-control-layers-separator {
  margin: 10px 0 !important;
  opacity: .25;
}

/* Cada linha */
.leaflet-control-layers label {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 6px;
  border-radius: 10px;
  cursor: pointer;
  user-select: none;
}

/* Hover */
.leaflet-control-layers label:hover {
  background: rgba(0,0,0,.05);
}

/* Inputs maiores */
.leaflet-control-layers input {
  transform: scale(1.15);
}

/* Texto */
.leaflet-control-layers span {
  color: #1f2937;
}

/* Scroll se muitas camadas */
.leaflet-control-layers-list {
  max-height: 45vh;
  overflow: auto;
  padding-right: 6px;
}

/* Scrollbar (WebKit) */
.leaflet-control-layers-list::-webkit-scrollbar { width: 8px; }
.leaflet-control-layers-list::-webkit-scrollbar-thumb {
  background: rgba(0,0,0,.18);
  border-radius: 10px;
}


/* Alinhar horizontalmente (topright) */
.leaflet-top.leaflet-right {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  gap: 10px;
}

.leaflet-top.leaflet-right .leaflet-control {
  margin: 10px 10px 0 0;
  float: none !important;
  clear: none !important;

}

/* Em mobile: empilha */
@media (max-width: 700px) {
  .leaflet-top.leaflet-right {
    flex-direction: column;
    gap: 0;
  }
}

/* Mantém o botão do Layers visível mesmo quando está expandido (Leaflet esconde-o por defeito) */
.leaflet-control-layers-expanded .leaflet-control-layers-toggle {
  display: block !important;
  cursor: pointer;
}

/* Dá-lhe aspeto “clicável” */
.leaflet-control-layers-toggle {
  cursor: pointer;
}

/* No canto top-right, queremos flex “a sério” */
.leaflet-top.leaflet-right {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  gap: 10px;
}

/* Leaflet usa floats/clear para empilhar. Em flex isso só atrapalha. */
.leaflet-top.leaflet-right .leaflet-control {
  float: none !important;
  clear: none !important;
  margin: 10px 10px 0 0;
  position: relative;
  z-index: 1000;
}

/* Mantém o ícone visível mesmo quando expandido (para poderes fechar) */
.leaflet-control-layers-expanded .leaflet-control-layers-toggle {
  display: block !important;
}

/* Garante que o toggle é clicável */
.leaflet-control-layers-toggle {
  cursor: pointer;
  pointer-events: auto;
}

/* Mantém o toggle visível mesmo expandido (já tinhas isto) */
.leaflet-control-layers-expanded .leaflet-control-layers-toggle {
  display: flex !important;
}

/* Tornar o toggle um botão com ícone + texto */
.layers-base .leaflet-control-layers-toggle,
.layers-overlays .leaflet-control-layers-toggle {
  width: auto !important;
  height: 42px !important;
  display: flex !important;
  align-items: center;
  gap: 10px;
  padding: 0 12px 0 12px;
  border-radius: 12px !important;

  /* remove o ícone default do Leaflet */
  background-image: none !important;

  /* aspecto */
  background: rgba(255,255,255,.92) !important;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 10px 30px rgba(0,0,0,.20) !important;

  font: 700 13px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  color: #1f2937;
  cursor: pointer;
  text-decoration: none;
}

/* Ícone (antes do texto) */
.layers-base .leaflet-control-layers-toggle::before,
.layers-overlays .leaflet-control-layers-toggle::before {
  content: "";
  width: 18px;
  height: 18px;
  display: inline-block;
  background-size: 18px 18px;
  background-repeat: no-repeat;
  background-position: center;
  opacity: .95;
}

/* Texto (na mesma linha) */
.layers-base .leaflet-control-layers-toggle::after {
  content: "Base";
}
.layers-overlays .leaflet-control-layers-toggle::after {
  content: "Camadas";
}

/* Ícone do Basemap (tipo mapa) */
.layers-base .leaflet-control-layers-toggle::before {
  background-image: url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'>\
<path fill='%231f2937' d='M9 4 3 6.5v13L9 17l6 2.5 6-2.5v-13L15 4 9 6.5V4zm0 4.2 6-2.5v11.1L9 17V8.2z'/>\
</svg>");
}

/* Ícone do Overlay (tipo camadas) */
.layers-overlays .leaflet-control-layers-toggle::before {
  background-image: url("data:image/svg+xml;utf8,\
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'>\
<path fill='%231f2937' d='M12 3 2 8l10 5 10-5-10-5zm0 7L2 5v3l10 5 10-5V5l-10 5zm0 6L2 11v3l10 5 10-5v-3l-10 5z'/>\
</svg>");
}

/* Hover bonito */
.layers-base .leaflet-control-layers-toggle:hover,
.layers-overlays .leaflet-control-layers-toggle:hover {
  background: rgba(255,255,255,.98) !important;
}

/* Se estás a usar flex no canto direito, neutraliza floats do Leaflet */
.leaflet-top.leaflet-right .leaflet-control {
  float: none !important;
  clear: none !important;
}

.legend{
  background: rgba(255,255,255,.92);
  padding:10px 12px;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.20);
  font: 13px/1.3 system-ui, sans-serif;
}
.legend .lg{ display:inline-block; vertical-align:middle; margin-right:8px; }
.legend .line{ width:26px; height:0; border-top:3px solid; }
.legend .eur{ border-color:#FF7800; }
.legend .cel{ border-color:#ee282f; }
.legend .no{ border-color:DodgerBlue; }
.legend .mar{ border-color:#FF7800; border-top-style:dashed; }
.legend .pin{ width:10px; height:10px; border-radius:50%; background:#7a1fa2; }


  </style>
</head>

<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-locatecontrol/0.85.1/L.Control.Locate.min.js"></script>

<script>
  const map = L.map('map', { preferCanvas: true }).setView([41.5, -8.0], 6);

  // Remove o prefixo "Leaflet ..." (onde estava a bandeira)
  map.attributionControl.setPrefix('<a href="https://leafletjs.com/">Leaflet</a>');

  // Localização
  L.control.locate({
  position: 'topleft',
  setView: 'once',         // centra uma vez
  keepCurrentZoomLevel: true
}).addTo(map);

  // Base layers
  const baseOSM = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  });

  const baseTerrain = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
    maxZoom: 17,
    attribution: 'Map data: &copy; OpenStreetMap contributors, SRTM | Map style: &copy; OpenTopoMap (CC-BY-SA)'
  });

  const baseHillshadeEsri = L.tileLayer(
    'https://services.arcgisonline.com/ArcGIS/rest/services/Elevation/World_Hillshade/MapServer/tile/{z}/{y}/{x}',
    { maxZoom: 20, attribution: 'Tiles &copy; Esri' }
  );

  const baseSatellite = L.tileLayer(
    'https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { maxZoom: 19, opacity: 0.9, attribution: 'Tiles &copy; Esri' }
  );

  // Ativa uma base
  baseSatellite.addTo(map);

  // Renderers
  const canvasRenderer = L.canvas({ padding: 0.5 });
  const svgRenderer = L.svg();

  // Overlays (criados já ligados, sem redundâncias)
  const tracksEUR = L.featureGroup().addTo(map);
  const tracksCEL = L.featureGroup().addTo(map);
  const tracksNO  = L.featureGroup().addTo(map);
  const tracksMAR = L.featureGroup().addTo(map);
  const IGR       = L.featureGroup().addTo(map);

  const baseLayers = {
    "Satélite": baseSatellite,
    "OpenStreetMap": baseOSM,
    "Sombreado": baseHillshadeEsri,
    "Terreno": baseTerrain
  };

  const overlays = {
    "Igrexas con axedrezado": IGR,
    "Camiños oficiais": tracksEUR,
    "Camiños marítimos": tracksMAR,
    "Via Céltica": tracksCEL,
    "Non oficiais": tracksNO,
  };



const ClickLayersControl = L.Control.Layers.extend({
  onAdd: function (map) {
    const container = L.Control.Layers.prototype.onAdd.call(this, map);

    // Desliga hover (Leaflet abre/fecha por mouseover/mouseout em desktop)
    L.DomEvent.off(container, 'mouseover', this.expand, this);
    L.DomEvent.off(container, 'mouseout',  this.collapse, this);

    // O link/ícone do controlo (Leaflet guarda em _layersLink)
    const link = this._layersLink;

    // Garante que clicar no ícone não mexe no mapa
    L.DomEvent.on(link, 'click', L.DomEvent.stop);

    // Alternar abrir/fechar a clicar no ícone
    L.DomEvent.on(link, 'click', () => {
      if (container.classList.contains('leaflet-control-layers-expanded')) {
        this.collapse();
      } else {
        this.expand();
      }
    });

    return container;
  }
});


// Controlos separados (clicar para abrir)
const baseControl = new ClickLayersControl(baseLayers, null, {
  collapsed: true,
  position: 'topright'
}).addTo(map);

const overlayControl = new ClickLayersControl(null, overlays, {
  collapsed: true,
  position: 'topright'
}).addTo(map);

baseControl.getContainer().classList.add('layers-base');
overlayControl.getContainer().classList.add('layers-overlays');

// Overlays aberto por defeito, mas fechável manualmente no ícone
overlayControl.expand();
baseControl.collapse();

function makeLayersControlClickOnly(ctrl) {
  const container = ctrl.getContainer();
  const toggle = container.querySelector('.leaflet-control-layers-toggle');

  // não deixar o controlo mexer no mapa
  L.DomEvent.disableClickPropagation(container);
  L.DomEvent.disableScrollPropagation(container);

  // 1) Mata hover (captura antes do Leaflet)
  const killHover = (e) => {
    e.stopPropagation();
    e.stopImmediatePropagation();
  };
  ['mouseover', 'mouseout', 'mouseenter', 'mouseleave'].forEach(ev => {
    container.addEventListener(ev, killHover, true); // capture=true
  });

  // 2) Toggle por clique no ícone (captura para ganhar ao Leaflet)
  toggle.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation(); // impede o click "expand-only" do Leaflet

    if (container.classList.contains('leaflet-control-layers-expanded')) {
      ctrl.collapse();
    } else {
      ctrl.expand();
    }
  }, true); // capture=true
}

makeLayersControlClickOnly(baseControl);
makeLayersControlClickOnly(overlayControl);

// overlays aberto por defeito, mas fechável manualmente no ícone
overlayControl.expand();
baseControl.collapse();


// (opcional) classes para poderes estilizar melhor em CSS
baseControl.getContainer().classList.add('layers-base');
overlayControl.getContainer().classList.add('layers-overlays');

  // Forçar ordem das camadas (reaplica em toggles)
  function applyLayerOrder() {
    // fundo -> topo
    tracksEUR.bringToFront();
    tracksCEL.bringToFront();
    tracksMAR.bringToFront();
    tracksNO.bringToBack();
    IGR.bringToFront();
  }
  applyLayerOrder();
//  map.on('overlayadd overlayremove', applyLayerOrder);

  // Loader
  async function loadGeoJSON(url, group, options = {}) {
    // caminhos relativos (bom para WP e GitHub Pages)
    const r = await fetch(`./${url}`, { cache: "no-cache" });
    if (!r.ok) throw new Error(`Falha a carregar ${url}: ${r.status}`);
    const data = await r.json();

    const layer = L.geoJSON(data, {
      ...(options.renderer ? {} : { renderer: canvasRenderer }),
      ...options
    });

    layer.addTo(group);
    return layer;
  }
// Legenda
const legend = L.control({ position: 'bottomright' });
legend.onAdd = () => {
  const div = L.DomUtil.create('div', 'legend');
  div.innerHTML = `
    <div><span class="lg pin"></span> Igrexas con axedrezado</div>
    <div><span class="lg line eur"></span> Camiños oficiais</div>
    <div><span class="lg line mar"></span> Marítimos</div>
    <div><span class="lg line cel"></span> Via Céltica</div>
    <div><span class="lg line no"></span> Non oficiais</div>
  `;
  return div;
};
legend.addTo(map);

  // Pin icon (SVG) com scale real
  function pinIcon(color = "#7a1fa2", scale = 1) {
    const w = 30 * scale;
    const h = 42 * scale;

    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 30 42">
        <path d="M15 0C7.3 0 1 6.1 1 13.7c0 10.3 14 28.3 14 28.3s14-18 14-28.3C29 6.1 22.7 0 15 0z"
              fill="${color}" />
        <circle cx="15" cy="14" r="5.5" fill="white"/>
      </svg>`;

    return L.divIcon({
      className: '',
      html: svg,
      iconSize: [w, h],
      iconAnchor: [w / 2, h],
      popupAnchor: [0, -h * 0.9]
    });
  }

  // Popups no ponto clicado (para linhas)
  function linePopupHandler(feature, layer) {
    const nome =
      feature?.properties?.name ??
      feature?.properties?.Name ??
      feature?.properties?.nome ??
      "Track";

    layer.on('click', (e) => {
      L.popup()
        .setLatLng(e.latlng)
        .setContent(nome)
        .openOn(map);
    });
  }
// Loading (antes do async)
const loading = L.control({ position: 'bottomleft' });
loading.onAdd = () => {
  const d = L.DomUtil.create('div', 'loading');
  d.textContent = 'A carregar…';
  return d;
};
loading.addTo(map);

(async () => {
  try {
    // Non oficiais
    const noOpts = {
      style: () => ({ color: "DodgerBlue", weight: 3, opacity: 0.9 }),
      onEachFeature: linePopupHandler
    };
    await loadGeoJSON('nao-oficiais.geojson', tracksNO, noOpts);
    await loadGeoJSON('var-inverno.geojson', tracksNO, noOpts);

    // Oficiais Europa (dois ficheiros na mesma camada)
    const eurStyle = { style: () => ({ color: "#FF7800", weight: 3, opacity: 0.9 }) };
    await Promise.all([
      loadGeoJSON('merged-EUR_simplified.geojson', tracksEUR, eurStyle),
      loadGeoJSON('manzanal.geojson', tracksEUR, eurStyle),
    ]);

    // Via Céltica
    await loadGeoJSON('via-celtica.geojson', tracksCEL, {
      style: () => ({ color: "#ee282f", weight: 3, opacity: 0.9 }),
      onEachFeature: linePopupHandler
    });

    // Marítimos (SVG para garantir tracejado)
    await loadGeoJSON('merged-MAR.geojson', tracksMAR, {
      renderer: svgRenderer,
      style: () => ({ color: "#FF7800", weight: 3, opacity: 0.9, dashArray: "8 6" }),
      onEachFeature: linePopupHandler
    });

    // Igrejas (pontos)
    await loadGeoJSON('igrejas.geojson', IGR, {
      pointToLayer: (feature, latlng) => L.marker(latlng, { icon: pinIcon("#7a1fa2", 0.7) }),
      onEachFeature: (feature, layer) => {
        const nome = feature?.properties?.name ?? feature?.properties?.Name ?? "Igreja";
        layer.bindPopup(nome);
      }
    });

    applyLayerOrder();

    // Se estiver embutido (WP tabs/iframes/containers), isto evita mapa “cortado”
    setTimeout(() => map.invalidateSize(), 200);

  } catch (e) {
    console.error(e);
    alert(e.message);
  } finally {
    loading.remove();   // <- aqui
  }
})();

</script>
</body>
</html>
